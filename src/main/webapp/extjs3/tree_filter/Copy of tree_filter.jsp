<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><%@ include file="/common/taglibs.jsp" %><html><head><meta http-equiv="Content-Type" content="text/html; charset=gbk"><title>Ext TreeFilter Demo1</title><link href="${ctx}/js/extjs-3.3.1-min/resources/css/ext-all.css" rel="stylesheet" type="text/css" /><script type="text/javascript" src="${ctx}/js/extjs-3.3.1-min/adapter/ext/ext-base.js"></script><script type="text/javascript" src="${ctx}/js/extjs-3.3.1-min/ext-all.js"></script><script type="text/javascript">//搜索框在Tree之外:  		http://topic.csdn.net/u/20100111/11/db824bd2-a1eb-4cd3-8669-d9b735f7eb1c.html//搜索框嵌入在Tree的tobbar里: http://hengrg.iteye.com/blog/619987//ext tree 的filter问题 	http://blog.sina.com.cn/s/blog_68141ec50100juhn.html//以下2种做法都是: 预先展开所有的节点,才能对这些节点进行过滤.如果树是收缩的,那么收缩下的节点是无法查询到的.//在大数据量的时候,展开所有节点速度会很慢的.//改进: 搜索时,先隐藏所有节点. -> 显示满足搜索条件的节点node[] node[i].ui.show() ->显示node[]的父节点,隐藏子节点.Ext.onReady(function(){    var tree = new Ext.tree.TreePanel({					// 树:构造树,获取数据展示树.    	autoScroll: true,    	width:200,		height:200,        loader: new Ext.tree.TreeLoader({            dataUrl: '../ext_tree_getNodes.jsp'        }),        root: new Ext.tree.AsyncTreeNode({            id: '0',            text: '根'        }),        renderTo: 'tree'    });    tree.expandAll();									// 展开树的所有节点    var filter = new Ext.tree.TreeFilter(tree, {		// 搜索=====开始        clearBlank: true,        autoClear: true    });    var hiddenPkgs = [];								// 保存上次隐藏的节点    var field = Ext.get('filter');						// 获取输入框的搜索条件值,不是上面定义的TreeFilter对象    field.on('keyup', function(e) {						// 按键后(鼠标一旦抬起,即一边输入一边立即进行查询)触发事件        var text = field.dom.value;        Ext.each(hiddenPkgs, function(n){				// 先要显示上次隐藏掉的节点            n.ui.show();        });        if(!text){										// 如果输入的数据不存在，就执行clear()            filter.clear();            return;        }        tree.expandAll();								// 展开所有节点.只有展开节点,才能对所有节点进行过滤.这种方式对于大数据不合适.        var re = new RegExp(Ext.escapeRe(text), 'i');	// 根据输入制作一个正则表达式，'i'代表不区分大小写        filter.filterBy(function(n){					// 过滤的方法.            return !n.isLeaf() || re.test(n.text);		// 只过滤叶子节点，这样省去(避免)枝干被过滤的时候，底下的叶子都无法显示            											// 枝干:!node.isLeaf=false,返回false.不搜索枝干!            											// n.text节点的值,re:根据搜索条件得到的正则        });        hiddenPkgs = [];								// 如果这个节点是枝干，而且下面没有子节点，就应该隐藏掉(枝干不搜索)        tree.root.cascade(function(n) {            if(!n.isLeaf() && n.ui.ctNode.offsetHeight < 3){                n.ui.hide();							// 隐藏枝干                hiddenPkgs.push(n);						//            }        });    })													// 搜索=====结束});//---------------------------------------------------------------Ext.onReady(function(){    var filter_tree = new Ext.tree.TreePanel({    	width:200,		height:200,		autoScroll: true,		rootVisible: false,				//uiProvider为Ext.tree.TreeCheckNodeUI? 		checkModel: 'cascade',		//对树的级联多选  		onlyLeafCheckable: false,	//对树所有结点都可选		        loader: new Ext.tree.TreeLoader({            dataUrl: '../ext_tree_getNodes.jsp',            baseAttrs:{				uiProvider: Ext.tree.TreeCheckNodeUI			}        }),        //root:new Ext.tree.TreeNode({		//无法看到树        root: new Ext.tree.AsyncTreeNode({	//异步方式获取树节点            id: '0',            text: '根'        }),        //节点点击事件:在右边构建一个Grid,未实现        listeners :{			"click": function(node,e){ 				if(node.id == 0){ 					return false; 				} 				var temp_Record1 = Ext.data.Record.create([ 					{name:"id"  ,type:'string'} 				   ,{name:"name",type:'string'} 				]); 				var tmprd1 = new temp_Record1({ 					id:node.attributes.id, 					name:node.attributes.text 				}); 								var_subjectds.insert(0,tmprd1); 				rdd.set("subjectCode",node.id); 				subCom.setValue(node.attributes.id); 				Ext.get(subCom.getId()).dom.value = node.attributes.text; 				subCom.setRawValue(node.attributes.text); 				subCom.collapse(); 				rdd.commit(); 			} 		}, 				tbar: [{			xtype: "textfield",	        emptyText: "请输入查询内容",	        width: 100,	        listeners:{				render: function(f){					//搜索=====调用函数filterTree    keydown,keyup,what about key enter which normally it's what we need					f.el.on('keydown', filterTree, f, {buffer: 350});				}			}	   	}],        renderTo: 'filter_tree'    });    filter_tree.expandAll();        //搜索=====开始    var hiddenPkgs = [];						//hide包数组	function filterTree(e) {		//Ext.each(hiddenPkgs, function (n) {	//遍历隐藏包数组	    //    n.ui.show();						//显示符合条件的节点	    //});		for(var i=0;i<hiddenPkgs.length;i++){ 	//for方式			hiddenPkgs[i].ui.show(); 		} 	    var text = e.target.value; 				//获得文本框的value	    var matched = [];						//匹配节点		var filter = new Ext.tree.TreeFilter(	//创建一个树过滤器对象			filter_tree, { 						//filter on tree	    		clearBlank: true,	    		autoClear: true		});	    if (!text) {							//如果没有过滤条件	        filter.clear();						//清空过滤器	        //filter_tree.root.collapse(true);	//collapse	        return;								//返回	    }	    filter_tree.expandAll();				//展开所有树节点	    var re = new RegExp(Ext.escapeRe(text), 'i');   				filter_tree.root.cascade(function(n) {	//找出所有匹配的结点			if(re.test(n.attributes.text)){				matched.push(n);			}		},this);		//从每个叶子结点向根方向处理,处理所有结点的枝叶,	    //如果该枝叶包含匹配的结点,则保留,否则裁剪掉(隐藏)	    filter_tree.root.cascade(function(n) {	        //if(n.isLeaf()){	            //处理每一条子结点路径	            n.bubble(function(nbb){	                //从叶子到根,逐个剪掉	                var contain = false;	                for ( var mted = 0; mted < matched.length; mted++) {	                    if(nbb.contains(matched[mted]) || nbb == matched[mted] ){	                        //包含匹配的结点	                        contain = true;	                        break;	                    }	                }	                //把不包含匹配结点的结点隐藏	                if(!contain){	                    nbb.ui.hide();	                    hiddenPkgs.push(nbb);	                    filter.filtered[nbb.id]=nbb;	                }	            },this);	       // }	     },this);	} 	//搜索=====结束});   </script></head><body>	<input id="filter" type="text" style="width:200px"/>	<div id="tree"> </div><br/>	<div id="filter_tree"> </div></body></html>