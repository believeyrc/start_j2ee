com.xuyuan.ssh/com.xuyuan.extjs3------------------------------------------------------------------整合步骤		1.jar包选择 | pom.xml配置	2.配置文件(applicationContext.xml,web.xml,struts2.xml)	3.公共类HibernateDao,StrutsAction;struts-convention-plugin	------------------------------------------------------------------Bean映射applicationContext_lib.xml#hibernate.cfg.xml关于实体Bean的映射上文已经讨论过.以下讨论的是方案2即applicationContext_ssh.xml的配置.	1.手动一个一个配置:	<property name="annotatedClasses">          <list>              <value>com.xuyuan.ssh.entity.base.User</value>                        <value>com.xuyuan.ssh.entity.base.Role</value>                    </list>   	</property> 		2.Spring提供的packagesToScan:	1).扫描entity包下面的所有包中的Bean注解类: com.xuyuan.ssh.entity.*		com.xuyuan.ssh.entity.							user.								User.java							role.								Role.java		com.xuyuan.ssh.action.							user.								UserAction							role.								RoleAction		2).entity包下的Bean类: com.xuyuan.ssh.entity		com.xuyuan.ssh.entity.							User.java							Role.java		com.xuyuan.ssh.action.							UserAction							RoleAction	3).根据业务来划分模块: com.xuyuan.ssh.*.entity		com.xuyuan.ssh.user.							entity.								User.java							action.								UserAction		com.xuyuan.ssh.role.							entity.								Role.java							action.								RoleAction								根据base-package指定的路径(一般具体到项目名)，扫描其下所有包含注解的Bean，并自动注入.持久层Dao类上的注解:@Repository,业务层Service类上的注解:@Service的Bean类被注入.业务层Service引用Dao层属性;Web层Action引用业务层Service的属性上的注解:@Autowired.注意entity包下的@Entity等注解不是Spring的注解,是JPA的注解要注意区分.Action上的@Results是convention的注解. 看其import的类就可以知道了.------------------------------------------------------------------事务控制需要事务控制的一般方法是:增删改.查不需要做事务控制.对应Spring的事务策略分别是:REQUIRED; readOnly.1.注解式事务[ssj]:<tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/>然后在业务类或方法中加入@Transactional这个注解标记，就完成事务声明，不过对于每个业务类都需要在类或方法中加入这些标记.	2.配置式事务[ssh]:使用切入点和通知配置事务.要求代码中的方法名称命名必须统一，就可以像如下这样定义事务规范. 即除了get,find,query,is开头(只是查询)事务控制方式为readonly,其他方法(insert,delete,update)都需要事务控制.但是实际项目中多人开发,可能写的方法名没有规则,最好是如果需要事务控制的统一命名比如upd*,del*.其他的方法不需要事务控制	<!-- 查找不需要事务,其他方法都需要事务控制 -->	<tx:method name="get*" read-only="true" />	<tx:method name="find*" read-only="true" />	<tx:method name="query*" read-only="true" />	<tx:method name="is*" read-only="true" />	<tx:method name="*" propagation="REQUIRED" />		<!-- CUD需要事务,其他方法不需要事务 -->	<tx:method name="upd*" propagation="REQUIRED"/>	<tx:method name="del*" propagation="REQUIRED"/>	<tx:method name="add*" propagation="REQUIRED"/>	<tx:method name="edit*" propagation="REQUIRED"/>	<tx:method name="remove*" propagation="REQUIRED"/>	<tx:method name="execute*" propagation="REQUIRED"/>	<tx:method name="persist*" propagation="REQUIRED"/>	<tx:method name="*" read-only="false"/>        <prop key="insert*">PROPAGATION_REQUIRED</prop>    <prop key="save">PROPAGATION_REQUIRED</prop>    <prop key="update*">PROPAGATION_REQUIRED</prop>    <prop key="edit*">PROPAGATION_REQUIRED</prop>    <prop key="del*">PROPAGATION_REQUIRED</prop>    <prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>    <prop key="query*">PROPAGATION_REQUIRED,readOnly</prop>                    Spring pointcut 表达式的含义:	* com.xuyuan.extjs3.service.*Impl.*(..)		service包下的以Impl结尾的类得所有方法[TreeServiceImpl]		* com.xuyuan.ssh.service..*Manager.*(..)	service的子包以Manager结尾的类的所有方法		* com.xuyuan.extjs3.service.*.*(..)			service包下的所有类的所有方法3.事务代理[hib]:采用baseTransactionProxy,可以看到这种方式看起来比较复杂.而且对于新增的业务需求,都要配置那么一大段代码的.