----------------------------------------------------------------------Ext Grid Demo: http://blog.csdn.net/myloon/archive/2007/11/08/1873652.aspx从Bean到Dao,再到Service,代码其实很好理解.主要是LevelAction这里的一些属性.以及ExtJSONActionSupport.ExtJsonActionSupport其实主要是定义了jsonstring以及分页信息.这些信息一般Action都要有的.所以抽取出来.jsonstring主要是为了在Action中得到Json字符串,这样Ext就可以利用这个JSON字符串得到数据集,构造Grid.应该能看到打印的Json数据[关于JSON可以查看struts2/json的例子]JSON数据在jsonExecute()中定义.当然可以按照自己的方式.比如:{success:true,count:xx,chidren:[{},{}]}{success:true, totalCount:5, list:[	{"description":"222","levelid":2,"levelname":"2222"},	{"description":"333","levelid":33,"levelname":"33333"}]}添加后如果出现'正在保存数据，稍后...' 而且数据库也插入了数据,那么可能是json_struts2.jsp你引用成别的了.----------------------------------------------------------------------Ext Tree Demo: http://localhost:8888/start_j2ee/treedemo.actionStruts2、Spring、Hibernate整合ExtJS http://www.cnblogs.com/hoojo/archive/2011/01/07/1929577.htmlSQL日志信息如下(pid='xx'可能不一样,第一句pid is null)	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and (pid is null)	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='1'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='2'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='3'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='4'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='5'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='7'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='8'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='9'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='10'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='11'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='12'	select categoryname ,id ,nodeid ,pid ,nodelevel from ssh_ext_sort where show=1 and pid='6'使用Chrome的JSONView插件可以很直观地看出JSON结构.	[		{"children":[			{"children":[],"id":2,"leaf":true,"nodeid":2,"nodelevel":0,"pid":1,"text":"湖里"},			{"children":[],"id":3,"leaf":true,"nodeid":3,"nodelevel":0,"pid":1,"text":"思明"}		],"id":1,"leaf":false,"nodeid":1,"nodelevel":0,"pid":0,"text":"厦门"},		{"children":[			{"children":[],"id":5,"leaf":true,"nodeid":5,"nodelevel":0,"pid":4,"text":"晋安"}		],"id":4,"leaf":false,"nodeid":4,"nodelevel":0,"pid":0,"text":"福州"}	]访问Action如何就得到上面的JSON数据?在execute方法中,我们一次性加载到了全部节点数据.得到tree.getChildren(). 而所有的数据都是层层嵌套进对应的父节点中去的.这意味着如果某个节点有子节点,则节点.setChidren(子节点).通过自关联,得到的List<Tree>.满足的是ExtTree认识的结构.再通过JSON-LIB工具即可把对象转换为Ext认识的JSON字符串.可改进的地方: 将Tree和Sort对象合二为一TreeDemoAction方法分析:	调用业务层的方法tree.setChidren或者tree.setLeaf. 下面的代码就可以tree.getChidren	那么这个tree对象到底是什么?DEBUG看下流程(由于采用接口,不能真正跳到断点,但是可以查看variable)	第一次时,new Tree(),虽然Tree对象不是空的.但是tree.getNodeid是空的,	select * from sort where pid is null得到的是根节点下的所有一级节点(除了根节点外的最上层的节点) 示例中是福州和厦门这2个节点	然后在业务层中,判断根节点下有一级节点(Dao层返回的子节点List:childs),有则tree.setChidren(childs)	然后递归调用自身方法,依次判断各个一级节点下的下一级节点...再下一级.直到遍历到某个节点没有子节点(childs.size)	这样一遍执行过去之后,Tree里存放的就是所有的树节点了.通过对象的children属性可以层层来寻找.	这也是为什么Tree设计List<Tree> children字段的原因.即Tree里自关联自身Tree.	Tree里有List<Tree> childs; childs的各个Tree对象里又可能有List<Tree> childs11 childs12...	这就是ExtTree数据库方式一次性加载全部节点的方式.	首先Bean要设计成自关联的List<> children字段	然后通过递归调用自身,setChildren(childs)	childs的获取是通过parentid来查询某节点下的所有子节点,从根节点开始...关于jsonString:	将结果转换为Ext可以认识的JSON字符串,如果是同步方式,则JSON格式必须含有children域	jsonString不是必须的.仅仅是为了测试返回的JSON字符串是否符合要求.所以jsonString.jsp也不是必须的了.TreeDaoImpl持久层数据库查询方法分析:-->getTreeListByParentId	将Sort对象的查询到的数据封装在Ext认识的Tree对象中	看看这条HQL语句,可以先分解成 select * from Sort 也就是说我们要的数据来自Sort这张表.	select categoryname,id,nodeid,pid,nodelevel from Sort where show=1 and pid...	查询后如果按照一般的HQL语句,返回的应该是个Sort对象吧.因为from Sort.-->HQL:select new Sort() from Sort	但是我们要把Sort对象转为Ext认识的Tree对象.-->HQL:select new Tree() from SOrt	所以,我们在select * 这个* 中转为Tree对象.	Tree对象需要的属性有: Tree(String text, Integer id, Integer nodeid, Integer pid,Integer nodelevel)-->Tree中的构造方法new Tree()即构造出Tree对象	就要求Sort中和Tree的对应上 categoryname,         id,         nodeid,         pid,        nodelevel	这里我们可以看出Sort对象的categoryname属性和Tree的text属性是对应的.其他依次类推.	HQL可以这么理解: select categoryname,id,nodeid,pid,nodelevele from Sort where show=1	然后把查询出来的对象(Object,因为不是Ext可认识的完整的对象) 转为Tree对象(Ext认识的对象还需要List<> children这个属性).---------------------------------------------------------------------ExtTreeCRUDhttp://yahaitt.iteye.com/blog/207696http://www.cnblogs.com/BruceLeey/archive/2009/06/06/1497851.htmlExt2.x树的扩展(选择树,下拉树,下拉选择树)	http://www.iteye.com/topic/164426	http://www.iteye.com/topic/164424	http://www.iteye.com/topic/212842Ext树过滤	http://topic.csdn.net/u/20100111/11/db824bd2-a1eb-4cd3-8669-d9b735f7eb1c.html	http://hengrg.iteye.com/blog/619987		Ext Tree 过滤	http://chemzqm.iteye.com/blog/653530	[Ext扩展]QM.ux.TreeFilter：树节点智能过滤,添加中文模糊匹配功能	http://chemzqm.iteye.com/blog/657602	[Ext插件]QM.plugin.MutilTreeFilter：为树添加过滤、展开、收缩功能